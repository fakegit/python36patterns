# 列举出4种编程方式，并介绍万能的oop 四步转化公式。
```
包含4种编程写法
1）模块级 全局变量  + 函数
2）在一组函数中无限频繁传参 和return
3）无效装逼废物滑稽面向过程类伪oop
4） 真oop
使用4种编程方式来实现男生、女生吃喝拉撒长身体，并说明缺点。

总结oop 四步转化公式。oop转化公式能够做到万能通用，适用一切任意编程场景，能够大幅度减少编程难度和减少代码行数。
只要按照这个公式写代码，就不需要死记硬背套设计模式。
此种编程方式，可以使任意极端纯面向过程代码的文件和项目减少50%行至95%行，写法更直观，并达到流程级可复用。
```

# 3 介绍神级别通用固定oop 4步转化公式，写代码下笔时候行云流水（只需学习这套固定面向过程转oop 4步走转化公式，远强于背诵设计模式）。

**使用这个公式，不需要背设计模式，不需要每次写新文件先花几天想破头皮怎么设计布局代码成为高扩展和高维护。**


[忘掉设计模式，使用最强最稳定最有固定套路的万能编程思维-python oop四步转化公式](https://github.com/ydf0509/python36patterns/tree/master/%E5%BF%98%E6%8E%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%9C%80%E5%BC%BA%E6%9C%80%E7%A8%B3%E5%AE%9A%E6%9C%80%E6%9C%89%E5%A5%97%E8%B7%AF%E7%9A%84%E4%B8%87%E8%83%BD%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4-python%20oop%E5%9B%9B%E6%AD%A5%E8%BD%AC%E5%8C%96%E5%85%AC%E5%BC%8F%E3%80%82)


这个oop四步走转化公式是最重要的，其他的36个设计模式python例子你在很多地方都能看到类似的。

先简要说明四步转化公式，具体的看上面链接的文档

## 3.1 四步走转化公式，具体步骤如下

### 第0步，按照模块+函数写python代码，脑子里面打草稿，写全局变量多多益善

**第0步是灵魂步骤，后面3步是死板的代码形式转化。你不做这一步，直接做后面三步，那就是写出无效废物装逼滑稽类，因为写出来也是面向过程的类。**

python模块文件下面多写全局变量，全局变量要多多益善；       
多个函数之间不要疯狂传递一大堆相同名字或意义的入参；      
每个函数末尾不要疯狂return一大堆中间状态变量；       
不要把这些return出来的变量，频繁传递给另外一个函数；   

**你应该尽可能全部设计成全局变量，然后每个函数里面去修改这一堆全局变量，这样就大幅避免了多个函数频繁传递一大堆入参，也不需要每个函数末尾疯狂return一大堆中间状态变量。**

这一步是脑子打草稿，多写全局变量，每个函数少传一大堆入参，少写return一大堆结果变量。 

这一步和老师教你要少写全局变量不同，似乎是反智，但请往下看。

### 第1步 模块降级为类名

就是要把模块级代码移到class 类下面

写个class 类，就是把你之前脑子打的草稿，模块 + 全局变量 + 函数，改成 类+实例属性+实例方法

### 第2步 全局变量降级为实例属性

之前为什么让你多写全局变量，就是为了这一步，全局变量降级为实例属性。你以为最终目的是为了多写全局变量吗？多写全局变量肯定是不行的是反语言的。

### 第3步 函数降级为实例方法

函数改为实例方法，但是函数第一个入参要加个self。

之前模块函数里面直接用全局变量 var_xx，现在实例方法里面读取和修这个"全局变量"，使用 self.var_xx。

## 3.2 oop 四步走转化公式的说明：

转化oop要有灵魂的第0步，如果跳过此步骤，直接执行第1到3步，就会想当然以为转化oop就是函数外面加个class关键字外壳，觉得转化没用。   
那是因为你不按照我说的步骤走，造成写成了无效废物装逼滑稽面向过程类，当然会觉得不需要转化。oop要的是内涵不要搞形式class外壳。

## 3.3 为什么要 oop 四步走转化，说明最根本核心原因

### 3.1 直接 模块级 + 多多益善的全局变量 + 函数  有什么问题？

```
最根本原因是因为模块是单例的，模块的变量是全局唯一的，例如按照第五章的代码你 描述一个人 吃喝拉撒(函数) 影响人的身高体重（全局变量）。

如果你要调用 小红 小明 小黄 小黑 4个人吃喝拉撒，由于全局变量只有一份，那会互相影响，因为全局变量没有隔离。小红调用吃饭，为什么要增加小明的体重？

所以你为了避免这种全局变量不适合多个人调用吃喝拉撒的问题，就写出了类似5.1教程的代码，写成了多个函数间疯狂传参，疯狂return一大堆变量，把这些变量再外部保存，并在函数间传来传去。
```

### 3.2 使用oop的天然多实例，每个实例的属性互不干扰的特性，天然解决全局变量只有一份的问题

```
既想写代码简单粗暴，全局变量加函数的思维，又要解决 全局变量只有一个，不能隔离的问题。那就是使用oop开发代码，     
oop的类天然就是多实例的，每个实例的属性是互不干扰的，天然解决全局变量只有一份的问题。

oop写代码后，类的每个对象的方法访问和修改实例属性，就像函数里面操作全局变量那样丝滑，并且是每个实例的属性天生是各自的，不会互相干扰的。      
你调用 小红.吃饭()  再也不用担心影响到 小明.体重 了。
```
### 3.3 不要用辩证法说有时候面向过程编程有时候更有优势 之类的话！

有的人就是杠精，我说 "考公务员都是精致的利己主义者，就是为了工资高 永不失业 退休金高"；   
他却辩证法说 "也有考公务员是为了成为高尚的人民公仆，例如雷锋就是不喜欢钱，就是喜欢把国家发的工资和退休金都捐给农村老人用"。

```
最怕有的人，完全不去思考为什么需要oop，自己懒得要死，上来就来一句 "有时候面向过程编程更简单更好" 的话 或者 "只有大项目才需要oop" 的话。

不要这么使用辩证法偷懒好吗。我没说过任何场景一定要用oop，最最关键的判断依据是你需不需要多实例， 你不需要多实例那就可以不要面向对象写法,
也不需要单例模式装逼写个类，你直接模块加函数就好了，反正不需要全局变量隔离的需求。

例如本文档第5章节，描写一个人吃喝拉撒运动影响了身高体重，这个需求是非常非常简单吧，绝对是你口中的小项目，绝对是你认为的不需要oop。
但事实就是，用oop来完成需求，比面向过程写法实现时候简单多了，最重要的是调用时候简单太多了。

为什么我写的所有包，例如 funboost  nb_time nb_log都很好用，都是用法十分简单但功能十分强大的python包，原因就是在于此。     
假如你来封装python三方包或框架给别人用，如果你不按我的思路写代码，就会造成不仅你自己实现框架时候很麻烦、很难扩展、爱出错、不好维护，    
更重要的是你把这个包发布出来后，即使功能能达到目的，但用户会感觉极端难使用、不好用、不方便。
例如5.1写法封装的模块，用户来调用人.吃饭() 和人.撒尿() ,用户需要风控传一大堆入参和接受并保存一大堆返回，体验太差了。
```



# oop转化公式的重要本质需要理解的方面
```
最重要是理解：  命名空间  全局变量  实例属性  多实例需求  函数和方法 的关系，搞清楚了，
写oop十分之简单，不会造成极端面向过程的曲折写法。
在word文档中会写更详细的解释。
```

# 常见问题解答
```
1、是不是所有代码都要用oop？
答：不是，按照上面的方式判断用那种方式好，再用oop转化公式，使用真正得oo编程。
如果只是对现有代码直接在函数上套个类名，函数改成方法，99%的情况下弄出来的只会是废物滑稽类，伪oop，
不能有写类就高大上能吓唬人装逼了这种想法。

2、函数和类上面区别？
没有区别，就像问人和走路有什么区别，猪和吃饭有什么区别，问得牛头不对马嘴的伪问题，函数和方法才可以比较。
类（对象）和模块才有可比性，必须要搞清楚原因，不然脑袋中有这个比较的想法那就不可能写得了oop。

面向过程是 文件模块名.eat(狗的名字，shit)
oop是  狗.eat(shit)
```

# python编程范式
```
1.1 方式一，平铺指令。 从上往下叠加指令，适合简单的独立脚本。不需要和没机会被别的模块导入。
1.2 方式二，面向过程函数式编程。适合实现独立的转化功能，基本原理是要实现转化 y = f(x)，
适合函数无依赖状态（不需要在多个函数中频繁的传入和return相同意义的参数）。
1.3 方式三，oop编程.适合多个函数间需要使用同一个变量，并且需要多实例（如果使在使用面向过程时候需要使用函数频繁的return各
种状态/变量由类外使用多个参数来保存这些值和传入这些值，那就是也判断为需要多实例），必须同时满足这两个条件，才使用oop好，
否则不需要oop。（但单例模式为了控制灵活的初始化传参，一般也用类的方式）
1.4 网上说的简单用面向过程，复杂的用面向对象，这简直是错误的废话。简单和复杂界定不了，即使是一个简单的查询价格，经过大量
平台的重写对比，oop都能比面向过程减少70%行以上的代码，所以用网上这句话来判断用什么方式来写代码是错误的。只要严格使用上面
描述的判断方式，就能很容易知道在什么场景什么时候使用哪种方式好了，不需要oop嗨写成类就是没理解好oop能更好地解决什么。
1.5 要多使用oop，但不要写成纯静态或者半静态的无效废物类。 面向过程一定可以搞定一切，但是实现麻烦、调用更麻烦，那就不适合
面向过程了。比如猴子补丁可以搞定继承，闭包可以搞定封装，但是没什么好处，实现麻烦。先要转oop，只有放弃极端面向过程，不对面
向过程过分的偏执和喜欢，才能开始学习更多设计模式。
```
